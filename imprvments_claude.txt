Получил полную картину. Вот детальный план по трём направлениям + архитектура.

  ---
  🔴 Критично — надёжность

  1. Logging вместо print()

  Сейчас 26+ мест с print("GSHEET ERROR: ..."). При падении бота ни один лог не сохраняется. Нужен logging.basicConfig +
   запись в файл. Одна правка в main.py, замена print → logger.error/warning по всему коду.

  2. Блокировки в кэше handlers.py

  В gsheet.py есть threading.Lock() — правильно. В handlers.py — нет. Все глобальные _RESPONSE_CACHE, _PROFILE_CACHE,
  _AI_RESPONSE_CACHE меняются без блокировок. При одновременных запросах — гонка данных.

  3. Инвалидация кэша после offline-синка

  При старте бота _sync_offline_entries заливает очередь в таблицу, но не сбрасывает _RECORDS_CACHE. Следующие команды
  отдают устаревшие данные.

  4. Таймаут для asyncio.to_thread

  Если Google Sheets зависает — бот ждёт бесконечно. Нужен asyncio.wait_for(asyncio.to_thread(...), timeout=15).

  5. Атомарная оффлайн-очередь

  offline_queue.py читает JSON → обрабатывает → пишет обратно. Если бот падает посередине — записи теряются. Нужно:
  записывать в файл атомарно (tmp → rename) или использовать SQLite.

  6. Мёртвая конфигурация

  KINOPOISK_TOKEN загружается в config.py, но нигде не используется. Удалить, чтобы не вводить в заблуждение.

  ---
  🟡 Производительность

  7. Кэш _RECENT_RECOMMENDATIONS_BY_SCOPE не очищается

  Словарь растёт вечно — для каждого пользователя хранится список до 40 заголовков. При большом количестве пользователей
   — утечка памяти. Нужен LRU-кэш или периодическая чистка.

  8. collect_tmdb_candidates — нет кэша между запросами

  При /recommend и /random в течение 30 минут TMDB вызывается заново. Профиль вкуса одинаков — кандидаты тоже будут
  одинаковые. Кэшировать список кандидатов на 15-20 минут.

  9. Таймаут Gemini не покрывает retry-паузы

  GEMINI_TIMEOUT_SECONDS = 20 — это таймаут одного HTTP-запроса. Но при 3 моделях × 3 попытках с backoff (1.5s, 3s, 6s)
  суммарное ожидание может быть 2+ минуты. Добавить общий таймаут на весь цикл.

  10. build_taste_profile вызывается не всегда через кэш

  Функция используется напрямую в offline_add.py и диагностике — без кэша. Это мелочь, но надо проверить.

  ---
  🟢 GUI / UX

  11. Нет постеров в /random

  TMDB возвращает poster_path, но он игнорируется. Добавить send_photo с caption — это кардинально меняет визуал.

  12. Кнопка «Добавить» в результатах /random и /recommend

  После показа фильма — кнопка ➕ Добавить этот фильм с предзаполненным /add Название;Год. Сейчас пользователь должен
  руками копировать из подсказки внизу.

  13. /winner — только текущий месяц

  Нет возможности посмотреть прошлые месяцы. Нужны кнопки ◀ Пред. месяц | Текущий | ▶.

  14. Подтверждение при /add без формы

  /add Интерстеллар;2014;фантастика;9 сохраняет немедленно, без превью. А форма — с превью. Логика должна быть единой.

  15. Нет обратной связи при /find и /search с 0 результатами

  Просто «Ничего не найдено» — и всё. Стоит предложить: «Попробуйте /find триллер или /random».

  ---
  🏗️ Архитектура — как рефакторить

  Текущая проблема

  handlers.py — 1755 строк, 4 разных ответственности:
  - Бизнес-логика (winner, stats, scoring)
  - Управление состоянием (add flow, кэши)
  - Форматирование (format_entry, format_ai_answer)
  - Telegram-специфика (send, send_panel, reply)

  Предлагаемая структура

  bot/
    handlers/
      __init__.py       # Экспорт всех хэндлеров для setup_bot.py
      library.py        # /list, /top, /recent, /find, /search, /owner
      stats.py          # /stats, /winner
      ai.py             # /ai, /recommend, /random, handle_photo
      add_flow.py       # /add, все состояния формы, confirm
      base.py           # /start, /help, /menu, handle_message, handle_callback
    interface.py        # (оставить как есть)
    setup_bot.py        # (оставить, только правим импорты)

  core/
    cache.py            # Единый модуль кэша с Lock, TTL, LRU
    logging_setup.py    # Настройка logging один раз
    gsheet.py           # (оставить)
    gemini.py           # (оставить)
    recommendations.py  # (оставить)
    config.py           # (оставить)
    normalization.py    # (оставить)
    offline_queue.py    # (оставить, но атомизировать)

  Единый модуль core/cache.py

  Сейчас кэш-логика разбросана в 3 файлах с разным качеством (в gsheet — с Lock, в handlers — без). Один CacheStore
  класс с TTL, LRU-выселением и thread-safety покроет всё.

  Приоритет рефакторинга

  Разбивку handlers.py делать последним — сначала стабилизировать надёжность (пп. 1-6), потом производительность (7-10),
   потом UX (11-15), и только после — архитектурный рефакторинг без риска сломать работающий код.

  ---
  Что реализовать в первую очередь?

  ┌─────┬────────────────────────────────┬───────────┬────────────────────────────┐
  │  #  │             Задача             │ Сложность │           Эффект           │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 1   │ Logging                        │ Низкая    │ Высокий — диагностика      │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 2   │ Lock в кэше handlers           │ Низкая    │ Высокий — надёжность       │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 3   │ Cache invalidation после синка │ 1 строка  │ Средний                    │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 8   │ Кэш TMDB-кандидатов            │ Средняя   │ Высокий — скорость /random │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 11  │ Постеры в /random              │ Средняя   │ Высокий — UX               │
  ├─────┼────────────────────────────────┼───────────┼────────────────────────────┤
  │ 12  │ Кнопка «Добавить» в /random    │ Низкая    │ Средний — UX               │
  └─────┴────────────────────────────────┴───────────┴────────────────────────────┘